# 逃逸分析
如果函数外部没有引用，则优先放到栈中； 2. 如果函数外部存在引用，则必定放到堆中；

go中的逃逸分析，说起来逃逸分析，是对象从栈中逃逸到了堆中，一个值被分享到函数栈帧范围之外，简单的来说就是一个对象本来是不需要gc的，但是它如果用了它的引用类型，
那么它的作用域就不仅限于它所在的那个栈了，就从栈中逃逸到了堆中，所以就变成由用户自己回收了，当然go中是gc，这个过程就可以称作是
队形的 escape to heap 逃逸分析。

### 逃逸场景

##### 引用类型被外部使用

```go
type A struct {

}
func NewA()*A {
  return &A{

  }
}

```
A就逃逸了。
#### 栈空间不够就逃逸到堆了

```go
func main(){
  a := make([]int,100000,10000)
  for k := range a {
    a[k]= a[k]+1
  }

}

```
如果栈空间不足，就会逃逸到堆中。

#### 动态类型
```go
func main(){
  a := "12"
  fmt.Prinln(a)
}
```
因为println 接收了一个interface{}的类型，所以它不知道具体是啥，那不逃逸在这个函数main中也完不成啊 不得不去prinln中再处理一下啊
  所以就逃逸了

#### 闭包

```go
func b()func(x int)int{
  return func (x int)int  {
    return x+1
  }
}
```

因为闭包的特性，这个x是不会被释放的，既然无法在这个函数体内完成所以就逃逸了

- **栈上分配内存比在堆中分配内存有更高的效率**
- 栈上分配的内存不需要GC处理
- 堆上分配的内存使用完毕会交给GC处理
- 逃逸分析目的是决定内分配地址是栈还是堆
- 逃逸分析在编译阶段完成

所以传递值不一定比传递指针慢，因为值是栈中处理，速度快，而指针是逃逸到堆中处理，慢，gc多
所以自己掂量啊。
